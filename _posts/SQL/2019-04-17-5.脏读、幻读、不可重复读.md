---
layout: post
title:  "4.脏读、幻读、不可重复读"
categories: "SQL"
tags: "mysql"
author: "songzhx"
date:   2019-04-17 21:44:00
---

## 1. 脏读、幻读、不可重复读

（1）**脏读** ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

（2） **幻读** : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

（3）**不可重复读** ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。



##  2. 不可重复读和幻读的区别

当然,  从总的结果来看,  似乎两者都表现为两次读取的结果不一致.

但如果你从控制的角度来看,  两者的区别就比较大
对于前者,  只需要锁住满足条件的记录
对于后者,  要锁住满足条件及其相近的记录

\-----------------------------------------------------------

我这么理解是否可以？
避免不可重复读需要锁行就行
避免幻影读则需要锁表

\------------------------

\#### 不可重复读和幻读的区别 ####
很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，**不能通过行锁来避免。需要Serializable隔离级别** ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

**所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。**

上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。



参考：

 https://uule.iteye.com/blog/1109647

https://www.cnblogs.com/itcomputer/articles/5133254.html