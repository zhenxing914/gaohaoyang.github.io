---
layout: post
title:  "字典序"
categories: "Hbase"
tags: "Hbase"
author: "songzhx"
date:   2019-03-11 15:19:00
---

Hbase中rowkey是按照字典序来进行存储，什么是字典序列，下面我们进行详细的介绍。

## 简单理解

设想一本英语字典里的单词，哪个在前哪个在后？

显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。

通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2)，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序[多元组](https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84)规定顺序：下面用形式化的语言说明。



## 形式定义

给定两个[偏序集](https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E9%9B%86)*A*和*B*,(*a*,*b*)和(*a*′,*b*′)属于[笛卡尔积](https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF) *A* × *B*，则字典序定义为

(*a*,*b*) ≤ (*a*′,*b*′) 当且仅当 *a* < *a*′ 或 (*a* = *a*′ 且 *b* ≤ *b*′).

结果是偏序。如果*A*和*B*是[全序](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BA%8F), 那么结果也是全序。



## 多个集合乘积的场合

上面的定义可以拓展：只要两个元素属于 A×B×...×N 这个笛卡尔积，或曰可写成 T1=(a1, b1, ..., n1) 和 T2=(a2, b2, ..., n2) 的有序多元组形式，那么两者即可排序——从前往后：

- 如果 a1 和 a2 没有顺序（按照 A 上的偏序，下同）：那么 T1 和 T2 没有顺序。
- 否则，如果 a1 在 a2 之前，那么 T1 在 T2 之前；反之若 a2 在 a1 之前，那么 T2 在 T1 之前。
- 否则 a1 和 a2 不分先后。接下来讨论 b1/b2、c1/c2 等等。

T1 和 T2 甚至可以不一样长：只要对应位置的元素所属的集合相同（第一个位置的元素都属于 A 集合、第二个位置的元素都属于 B 集合、等等），即可套用上面的做法。如果比到后面发现两者之一的元素先耗尽了，那么可视情况规定短者排在前或在后。

回到英语单词的例子上来。单词可以说是在笛卡尔积 A×A×A×... 这个集合（其中集合 A 是二十六个英文字母的集合，注意组成笛卡尔积的这些集合不必彼此不同）上的多元组，那么在字典中排列单词的顺序就是这里说的字典序——这也就是“字典序”这个名称的由来。

举例来说，全[排列](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%88%97) {1,2,3} 按照字典序的下一个排列分别是 123、132、213、231、312 和 321。如果就数字集合 {1, 2, 3, ..., n} 的排列而言，这个集合的全排列本身可以看成是 n [进制](https://zh.wikipedia.org/wiki/%E8%BF%9B%E5%88%B6)的数，这种情况下，所有排列的字典序等价于所有按照全排列顺序把数字写成的数集合的升序。



## 参考

https://zh.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E5%BA%8F

