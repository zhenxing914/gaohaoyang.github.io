> 分区并不代表并行度，
>
> 分区个数代表任务数。
>
> 分区个数建议是cpu核数的2-3倍为最优。

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpdoqyqdj5j31680ewn7y.jpg" alt="image-20210409184927435" style="zoom:50%;" />



## 1. 并行度

1、怎样提高并行度？

几种方式：(1)reduce时，输入参数(int)   (2)partitionBy()输入分区数  (3)SparkContext.textFile(path,num)

2、什么情况下需要提高并行度？

(1).partition的个数是split size决定的，spark的底层还是用的hadoop的fileformat，当你制定了一个可以切分的format，他就会按照splitsize去切partition，这个决定了任务会被分成多少份。

(2).节点个数跟cpu的核数决定了你能起多少实例，就是资源池。

(3).如果你partition的数量多，能起实例的资源也多，那自然并发度就多，如果你partition数量少，资源很多，它也不会有很多并发，如果你partition的数量很多，但是资源少，那么并发也不大，他会算完一批再继续起下一批



## 2. 集群的节点个数、RDD分区个数、cpu内核个数三者与并行度的关系

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ge4yhw2afgj30hs080t9g.jpg)

### 1. Block

输入可能以多个文件的形式存储在HDFS上，每个File都包含了很多块，称为**Block**。

### 2. inputSplit

当Spark读取这些文件作为输入时，会根据具体数据格式对应的InputFormat进行解析，一般是将若干个Block合并成一个输入分片，称为**InputSplit**，注意InputSplit不能跨越文件。

### 3. Task

随后将为这些输入分片生成具体的**Task**。InputSplit与Task是**一一对应**的关系。

### 4. Executor

随后这些具体的Task每个都会被分配到集群上的某个节点的某个**Executor**去执行。

- 每个节点可以起一个或多个Executor。
- 每个Executor由若干**core**组成，每个Executor的每个core**一次只能执行一个**Task。
- 每个Task执行的结果就是生成了目标**RDD**的一个**partiton**。



**注意:** 这里的core是虚拟的core而不是机器的物理CPU核，可以理解为就是Executor的一个工作线程。

**而 Task被执行的并发度 = Executor数目 * 每个Executor核数。**



至于partition的数目：

- 对于数据读入阶段，例如sc.textFile，输入文件被划分为多少InputSplit就会需要多少初始Task。
- 在Map阶段partition数目保持不变。
- 在Reduce阶段，RDD的聚合会触发shuffle操作，聚合后的RDD的partition数目跟具体操作有关，例如repartition操作会聚合成指定分区数，还有一些算子是可配置的。



————————————————
版权声明：本文为CSDN博主「highfei2011」的原创文章，遵循 CC 4.0 BY-NC-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/high2011/article/details/72356894