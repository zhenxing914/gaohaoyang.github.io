---
layout: post
title:  "IO模型-UNIX下五种I/O模型"
categories: "Java"
tags: "java  nio"
author: "songzhx"
date:   2018-06-29 17:00:00

---


## 1. Unix下五种I/O模型

Unix下共有五种I/O模型：

　　**1. 阻塞式I/O** 

　　**2. 非阻塞式I/O** 

　　**3. I/O复用（select和poll）** 

　　**4. 信号驱动式I/O（SIGIO）** 

　　**5. 异步I/O（POSIX的aio_系列函数）** 

io请求分两步：

　　**1. 先将数据从存储介质（磁盘，网络等）拷贝到内核缓冲区，此时称为数据准备好，可以被用户应用程序读取。**


　　**2. 由用户应用程序拷贝内核缓冲区中的数据到用户缓冲区。** 



------

### 1.1  阻塞I/O模型            进程一直阻塞，直到数据拷贝完成

我们将函数recvfrom视为系统调用，不论该函数如何实现，一般都会有一个从应用进程中运行到内核中运行的切换，一段时间以后还会有一个返回到应用进程的切换。

应用程序调用一个IO函数，导致应用程序阻塞并等待数据准备就绪。如果数据没有准备好，一直等待。如果数据准备好了，则从内核拷贝到用户空间拷贝数据，IO函数返回成功指示。

<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcvgkzt4j30rx0c8q47.jpg" alt="img" style="zoom:67%;" />

进程调用recvfrom，此系统调用直到数据报到达且被复制到应用进程的缓冲区中或发生错误才返回，常见的错误如系统调用被信号中断。

进程在调用recvfrom开始到它返回的整段时间内是被阻塞的，该函数成功返回后，应用进程开始处理数据报。

### 1.2 非阻塞I/O模型          数据就绪之前一直轮询

我们把一个套接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试 数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。

<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcvgzrtgj30tj0fdacl.jpg" alt="img" style="zoom:67%;" />

　　前三次调用recvfrom时仍无数据返回，因此内核立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时，数据报已准备好，被拷贝到应用缓冲区，recvfrom 返回成功指示，接着就是我们处理数据。

 　　当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom 时，我们称此过程为轮询（polling）。由于应用进程像这样连续不断地查询内核，看看某操作是否准备好，这对CPU时间是极大的浪费，所以这种模型只是偶尔才会遇到。

### 1.3. I/O复用模型        新增了一个系统调用select, 帮助进程监控多个I/O

I/O复用模型会用到select或者poll函数，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。 <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcvhj1koj30v60i3wgq.jpg" alt="img" style="zoom:67%;" />

　　只要有数据就绪，select调用返回，应用程序调用recvfrom将数据从内核区拷贝至用户区。

　　仔细看实例图，发现select模型似乎有些disadvantage，即前后进行了两次系统调用，比上一个模型多了一次。然而，select模型也有其明显的优势：每次select阻塞结束返回后，可以获得多个准备就绪的套接字（即一个select可以对多个套接字进行管理，类似于同时监控多个套接字事件是否就绪）。

　　和阻塞IO模型相比，selectI/O复用模型相当于提前阻塞了。等到有数据到来时，再调用recv就不会因为要等数据就绪而发生阻塞。

### 1.4. 信号驱动I/O模型         进程通过接收到的信号确认数据准备就绪

我们可以用信号，让内核在数据就绪时用信号SIGIO通知我们，将此方法称为信号驱动I/O 

　　首先，我们允许套接字进行信号驱动I/O，并通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的。当数据报准备好被读时，就为该进程生成一个SIGIO信号。我们随即可以在信号处理程序中调用 recvfrom 来取读数据报。

<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcviha87j30tw0gg40l.jpg" alt="img" style="zoom:67%;" />

### 1.5. 异步I/O    进程不受阻塞，将任务交给内核处理

我们让内核启动操作，并在整个操作完成后（包括将数据从内核拷贝到我们自己的缓冲区）通知我们。

调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。

<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcvjel9cj30si0emabl.jpg" alt="img" style="zoom:67%;" />

## 2. 对比五种 I/O模型 

前四种模型主要区别在第一阶段，因为前四种模型的第二阶段基本相同：在数据从内存拷贝到调用者的缓冲区时，进程阻塞于recvfrom 调用。然而，异步I/O模型处理的两个阶段都不同于前四个模型。

  <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcvjw5pej30t90hpwha.jpg" alt="img" style="zoom:67%;" />

## 3. 同步I/O与异步I/O

- 同步I/O：在I/O操作未完成前，请求进程会被阻塞
- 异步I/O：在I/O操作未完成前，请求进程未被阻塞

上述五种I/O模型，前四种均属于同步I/O（它们等待方式不同，搬迁动作相同），因为recvfrom调用均阻塞了当前请求进程。

只有最后一种IO属于异步I/O ！

 

　　所谓同步，数据从存储介质拷贝到内核缓冲区（数据准备的过程）完成之后，**需要用户自己将数据拷贝到用户缓冲区。**
　　所谓异步，步骤1，2 用户都不关心，只要发起IO请求，后面得到IO结果即可。
所以，前4种IO模型都是同步的！！！

 

阻塞，非阻塞，同步，异步  概括：

- 阻塞，非阻塞：**进程/线程要访问的数据是否就绪，进程/线程是否需要等待；**
- 同步，异步：**访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。**



## 4. 引用文章：

http://www.cnblogs.com/Lynn-Zhang/p/5711849.html 