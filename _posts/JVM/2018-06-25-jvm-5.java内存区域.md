---
layout: post
title:  "java内存区域与内存溢出-1.java内存区域"
categories: "jvm"
tags: "jvm"
author: "songzhx"
date:   2018/06/25 17:45:21 
---

java运行时数据区介绍

![img](https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcqyjucvj319s0l6q5t.jpg)



## 1. 程序计数器

​	每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。



## 2. 虚拟机栈

​	java虚拟机栈也是线程私有的，他的生命周期与线程相同。

​	虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表/操作数栈/动态链接/方法出口**等信息。每一个方法从调用知道执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。



## 3. 本地方法栈

​	本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈则为虚拟机使用到的Native方法服务。



## 4. Java堆

​	java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区唯一的目的就是存放对象实例。



## 5. 方法区

​	方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机**加载的类信息/常量/静态常量/即时编译器编译后的代码**等数据。



## 6. 运行时常量池

​	运行时常量池是方法区的一部分，Class文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

```java
int i = 1; // 把整数1赋值给int型变量i，整数1就是Java字面量，
String s = "abc"; // abc也是字面量。
```



## 7. 直接内存

​	直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。

NIO类引入一种基于通道与缓冲区的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

​	本机直接内存的分配不会受到java堆大小的限制，但是，既然是内存，肯定会受到本机总内存的限制。



## 8. 其他

### 永久代和方法区的关系

 涉及到内存模型时，往往会提到永久代，那么它和方法区又是什么关系呢？**《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。**那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。因此，我们得到了结论，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其他的虚拟机实现并没有永久带这一说法。

### 元空间

 对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间。它和永久代有什么不同的？存储位置不同，永久代物理是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。



————————————————
版权声明：本文为CSDN博主「抽离的心」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u011635492/article/details/81046174

