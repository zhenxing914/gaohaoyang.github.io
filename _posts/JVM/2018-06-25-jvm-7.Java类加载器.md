---
layout: post
title:  "Java类加载器ClassLoader"
categories: "jvm"
tags: "jvm 类加载器 ClassLoader"
author: "songzhx"
date:   2018/07/18 17:20:00 
---

## 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载 7个阶段。其中验证、准备、解析3部分称为连接。这7个阶段的发生顺序如图：

![img](https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcqx3ri8j319q0baq4h.jpg)



## 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放倒Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。



### 1. 类与类加载器

类加载器虽然只是用于实现类的加载动作，但它载Java程序中启动的作用远远不限制于类加载阶段。对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达的更通俗一些：比较两个类是否“相同”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类源于同一个Class文件，被用一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必须不相等。




### 2. 双亲委派模型

从java开发人员的角度来看，类加载器可以分为3种：

- 启动类加载器

- 扩展类加载器

- 应用程序类加载器

  

<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcqxl1bej30fu0ikq3v.jpg" alt="image-20190212110240349" style="zoom:50%;" />



图中展示的类加载器之间的这种层次关系， 称为类加载器的双亲委派模型。

​	双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不以继承的关系来实现，而是都使用组合关系来复用加载器的代码。

​	双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，**它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成**，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要的类）时，子加载器才会尝试自己去加载。

​	使用双亲委派模型来组织类加载器之间的关系，**有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系**。例如类java.lang.Object，它存在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因为Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为就无法保证，应用程序也将会变得一片混乱。